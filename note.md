# Note

3个部分：迭代（设置终点，生成较高质量的pc），聚类，调整权重（计算纳什均衡）

## 配置
考虑有什么变量，以什么数据结构存储？

采用python字典作为配置文件
如果有更好的数据结构再说

一个pc有什么变量？
> 卡片（类型，等级，技能位，品质，？成长值，？白天黑夜）
> **M=0白天，M=1黑夜，-1不作区分**
> 争夺等级
> **这个不应该是全局变量**
> 许愿池
> 护符
> 装备列表（属性）
> 光环点数、列表
> **这个不应该是全局变量**
> 权重

哪些是全局变量？
> 卡片的等级、技能位、品质
> **Level, Skill slot, Quality**
> 许愿池
> **Wish列表**
> 护符
> **Amulet字典**
> 装备属性
> **Level, Percentage, Myst percentage**

哪些是分组的变量？
> 争夺等级
> **Player level**
> 光环点数
> **Aura value**
> 数量
> **Size**

计算pc的参数？
> THREADS
> TESTS或CITEST
> SEEDMAX
> MAXATTR
> **MAXATTR是计算时调整参数用的，不放在配置**
> VERBOSE

需要以lib存储什么？
> 卡片名称（是否成长值，是否分白天夜晚）
> **用字典，卡片名称为键，值为字典，其中有Growth和Time两个属性**
> 装备名称（部位，是否神秘，是否为专属神秘）
> **用字典，卡片名称为键，值为字典，其中有~~Type~~（划掉）Position和Myst两个属性**
> **暂时没想好专属咋存储，目前非专属是'Myst':True，专属是'Myst':'AI'，遇到类型问题再改**
> 光环名称（点数？）
> **用字典，卡片名称为键，值为Cost点数**

## 迭代

4个部分：初期，初步生成，增加精度生成，最终生成
步长各设置为多少？
关键因素：时间

### 建模
研究对象：SSS，下面的以后再支持哈
卡片850，争夺等级分布900-1500（800-1600），光环分布270-290，别的都满配，正态得了
无神秘装备全150，神秘装备全140
生成指定数量个号位 **暂定100个**
每轮迭代时，随机抽取一个号位，检查其胜率是否低于所在组别平均，若低于，则用apc更新该号位的pc

### 实现
如何存储pc数据？
> 用json，方便读写
> 需要json->str和str->json
> 是否需要写个类？
> 包含哪些属性？
> pc本身的有：
> > ?Mode, ?Weight, Card, ?Name, ?Growth, ?Time, Level, Player level, Skill slot, Quality,
> > **Weight为小数时不好转化为字符串，暂时认为Weight都是整数**
> > Wish（用List）
> > ?Amulet（21项的Dict）
> > Attribute（Str, Agi, Int, Vit, Spr, Mnd）
> > Weapon（）
> > Hand（）
> > Body（）
> > Head（）
> > Aura（用List？）
> 
> 用于迭代的有：
> > Turn
> > Group
> > 号位
> > **用Number**
> > 迭代用的权重
> > **用Weight**
> > 一些算法中标记是否使用
> > **用Mark**
> 
> 但是json->str和str->json只能包含pc本身的属性，咋办？
> **将pc分为Data和Parameter两项**

如何存储装备？
> 装备名称（用name还是啥？type已经用来做部位了）
> **用Type**
> Level
> Percentage（列表）
> Myst

如何写算点方法？
> 需要哪些参数？
> **pc参数：成长值，等级，争夺等级，技能位，品质，许愿池，护符**
> **当前卡片**
> **全局参数（可限制到卡片）：装备列表，光环列表，MAXATTR**
> **计算参数：线程数，种子数，test数**
> 如何获取参数？
> **pc参数：直接读**
> **当前卡片：for**
> **全局参数：专门写个get_list**
> **计算参数：直接读**
> 如何填写newkf\.in？
> 算完点以后怎么读取结果？
> 该结果如何返回？

# 暂时不考虑分攻守

如何存储胜率信息？
> 存储后，每轮只需要O(n)次bpc
> 读取？
> 可以存储当前pc胜率表，每轮进行更新，另外把每次新pc对其他的胜率单独存储
> 迭代中只用读取当前胜率表(n^2)，统计只用读取O(n)的胜率

具体怎么一个迭代流程？
> 1. 初始化（随机生成100个pc）
> 2. 重置pc（把每个pc都重新apc一遍）
> 3. 低精度迭代（无限制）
> 4. 统计，排除不可能的组合，作出限制
> 5. 重置pc（是否必要？）
> **既然不含不可能的组合，好像不用**
> 6. 中精度迭代（弱限制）
> 7. 统计，对低频率组合作出出现概率限制
> 8. 重置pc（是否必要？）
> 9. 高精度迭代（强限制）

流程中每一步干啥？
1. 初始化
> random，类别好说，属性和（基本上）已解决，光环点数应该也有相应算法，实在没办法不均匀随机也行

2. 重置pc
随机选择一个号位，更新为apc后的pc，然后进行标记防止再被选中，共100次

3. 低精度迭代
随机选择一个号位，更新为apc后的pc，然后将其权重重置为1，其余未被选中的权重+1

4. 统计，限制


5. 重置pc（？）


6. 中精度迭代


7. 统计，限制


8. 重置pc（？）


9. 高精度迭代


#### 1.初始化（completed）
random生成data
为data添加参数形成pc
把pc存储进入pc.json

#### 2.重置pc
while
random选择一个号位（如何random？组间是否加权？）
将该号位的data更新为apc后的结果（如何apc？）
该号位的mark更新为true
if 所有号位mark均为true
break
所有号位mark更新为false